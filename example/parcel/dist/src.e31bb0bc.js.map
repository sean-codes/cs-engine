{"version":3,"sources":["../node_modules/cs-engine/src/parts/Camera.js","../node_modules/cs-engine/src/parts/Draw.js","../node_modules/cs-engine/src/parts/Fps.js","../node_modules/cs-engine/src/parts/Fullscreen.js","../node_modules/cs-engine/src/parts/InputKeyboard.js","../node_modules/cs-engine/src/parts/InputMouse.js","../node_modules/cs-engine/src/parts/InputTouch.js","../node_modules/cs-engine/src/parts/Loader.js","../node_modules/cs-engine/src/parts/Loop.js","../node_modules/cs-engine/src/parts/Math.js","../node_modules/cs-engine/src/parts/Network.js","../node_modules/cs-engine/src/parts/Object.js","../node_modules/cs-engine/src/parts/Room.js","../node_modules/cs-engine/src/parts/Setup.js","../node_modules/cs-engine/src/parts/Sound.js","../node_modules/cs-engine/src/parts/Sprite.js","../node_modules/cs-engine/src/parts/Surface.js","../node_modules/cs-engine/src/parts/Storage.js","../node_modules/cs-engine/src/parts/Timer.js","../node_modules/cs-engine/src/parts/Vector.js","../node_modules/cs-engine/src/main.node.js","objects/block.js","index.js","../node_modules/parcel-bundler/src/builtins/hmr-runtime.js"],"names":["module","exports","create","object","cs","draw","setColor","fillRect","x","y","width","height","CS","require","window","canvas","objects","start","console","log","type","OVERLAY_ID","OldModule","bundle","Module","moduleName","call","hot","data","hotData","_acceptCallbacks","_disposeCallbacks","accept","fn","push","dispose","checkedAssets","assetsToAccept","parent","isParcelRequire","WebSocket","hostname","location","protocol","ws","onmessage","event","JSON","parse","handled","assets","forEach","asset","isNew","didAccept","hmrAcceptCheck","global","parcelRequire","id","every","generated","js","clear","hmrApply","v","hmrAcceptRun","reload","close","onclose","removeErrorOverlay","error","message","stack","overlay","createErrorOverlay","document","body","appendChild","getElementById","remove","createElement","stackTrace","innerText","innerHTML","getParents","modules","parents","k","d","dep","Array","isArray","length","concat","Function","deps","cached","cache","some","cb"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFAA,MAAM,CAACC,OAAP,GAAiB;AACdC,EAAAA,MADc,wBACS;AAAA,QAAdC,MAAc,QAAdA,MAAc;AAAA,QAANC,EAAM,QAANA,EAAM;AACtB,GAFa;AAIdC,EAAAA,IAJc,uBAIO;AAAA,QAAdF,MAAc,SAAdA,MAAc;AAAA,QAANC,EAAM,SAANA,EAAM;AAClB;AACAA,IAAAA,EAAE,CAACC,IAAH,CAAQC,QAAR,CAAiB,KAAjB;AACAF,IAAAA,EAAE,CAACC,IAAH,CAAQE,QAAR,CAAiB;AACdC,MA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","file":"src.e31bb0bc.js","sourceRoot":"../src","sourcesContent":["//----------------------------------------------------------------------------//\n//-----------------------------| CS ENGINE: CAMERA |--------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_CAMERA {\n      constructor(cs) {\n         this.cs = cs\n\n         this.x = 0\n         this.y = 0\n         this.centerX = 0\n         this.centerY = 0\n         this.followPos = { x: 0, y: 0 }\n         this.zoom = 1\n         this.targetZoom = 1\n         this.scale = 1\n         this.width = 0\n         this.height = 0\n         this.maxWidth = 0\n         this.maxHeight = 0\n         this.smoothing = 1\n         this.smoothingZoom = 1\n\n         this.config = {\n            maxWidth: 0,\n            maxHeight: 0,\n            scale: 1,\n            zoom: 1,\n            smoothing: 1, // 1 means 1:1 movement\n            smoothingZoom: 1,\n            fixedScaling: true\n         }\n      }\n\n      // should happen once\n      setup(options) {\n         this.configure(options)\n         this.scale = this.config.scale\n         this.maxWidth = this.config.maxWidth\n         this.maxHeight = this.config.maxHeight\n         this.cs.resize()\n      }\n\n      // can change anytime (zoom, smoothing, etc)\n      configure(options) {\n         for (var option in options) {\n            this.config[option] = options[option]\n         }\n\n         this.smoothing = this.config.smoothing\n         this.smoothingZoom = this.config.smoothingZoom\n      }\n\n      resize() {\n         var w = this.cs.canvas.width\n         var h = this.cs.canvas.height\n\n         if (this.maxWidth && this.maxHeight) {\n            this.scale = this.config.fixedScaling\n               ? Math.max(1, Math.ceil(h / this.maxHeight))\n               : h / this.maxHeight\n\n            if (this.scale < w / this.maxWidth) {\n               this.scale = this.config.fixedScaling\n                  ? Math.max(1, Math.ceil(w / this.maxWidth))\n                  : w / this.maxWidth\n            }\n         }\n\n         this.width = w / this.scale\n         this.height = h / this.scale\n      }\n\n      snap(pos) {\n         this.follow(pos)\n         this.update(1)\n      }\n\n      follow(pos) {\n         this.followPos = {\n            x: pos.x,\n            y: pos.y\n         }\n      }\n\n      update(smoothing) {\n         var smoothing = this.cs.default(smoothing, this.smoothing)\n\n         // smooth zooming\n         var differenceZoom = this.config.zoom - this.zoom\n         this.zoom += differenceZoom / this.smoothingZoom\n         // if zooming turn smoothing off\n         if (differenceZoom) smoothing = 1\n\n         var scale = this.info().zScale\n         this.width = this.cs.canvas.width / scale\n         this.height = this.cs.canvas.height / scale\n\n         var differenceX = this.followPos.x - (this.x + this.width/2)\n         var differenceY = this.followPos.y - (this.y + this.height/2)\n\n         this.x = this.x + differenceX / smoothing\n         this.y = this.y + differenceY / smoothing\n\n         if (this.x < 0) this.x = 0\n         if (this.y < 0) this.y = 0\n\n         if (this.x + this.width > this.cs.room.width) {\n            this.x = (this.cs.room.width - this.width) / (this.cs.room.width < this.width ? 2 : 1)\n         }\n\n         if (this.y + this.height > this.cs.room.height) {\n            this.y = (this.cs.room.height - this.height) / (this.cs.room.height < this.height ? 2 : 1)\n         }\n\n         this.centerX = this.x + this.width/2\n         this.centerY = this.y + this.height/2\n      }\n\n      zoomOut() {\n         if(this.config.zoom >= 2) this.config.zoom -= 1\n      }\n\n      zoomIn() {\n         this.config.zoom += 1\n      }\n\n      outside(rect) {\n         if (\n               rect.x + rect.width < this.x\n            || rect.x > this.x + this.width\n            || rect.y + rect.height < this.y\n            || rect.y > this.y + this.height\n         ) {\n            return true\n         }\n         return false\n      }\n\n      info() {\n         return {\n            zoom: Math.round(this.zoom * 1000) / 1000,\n            scale: Math.round(this.scale * 1000) / 1000,\n            zScale: Math.round(this.scale * this.zoom * 1000) / 1000,\n            x: Math.round(this.x * 1000) / 1000 - 0.005, // prevent 0.5 artifacts\n            y: Math.round(this.y * 1000) / 1000 - 0.005,\n            width: Math.round(this.width * 1000 + 0.010) / 1000,\n            height: Math.round(this.height * 1000 + 0.010) / 1000\n         }\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_CAMERA\n      : cs.camera = new CSENGINE_CAMERA(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: DRAW |---------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_DRAW {\n      constructor(cs) {\n         this.cs = cs\n         this.debug = {}\n         this.surface = {}\n         this.config = {\n            defaults: {\n               alpha: 1,\n               width: 1,\n               font: { size: 12, family: 'Arial' },\n               textAlign: 'start',\n               textBaseline: 'top',\n               color: '#000',\n               lineHeight: 10,\n               lineDash: [],\n               operation: 'source-over'\n            },\n            current: {} // will clone on settingsDefault()\n         }\n      }\n\n      setSurface(surface) {\n         this.surface = surface\n         this.scale = 1\n         this.cameraX = 0\n         this.cameraY = 0\n         this.cameraWidth = this.surface.width\n         this.cameraHeight = this.surface.height\n         this.zScaleHack = 0\n\n         if (this.surface.useCamera && this.surface.oneToOne) {\n            var camera = this.cs.camera.info()\n\n            this.scale = camera.zScale\n            this.cameraX = camera.x\n            this.cameraY = camera.y\n            this.cameraWidth = camera.width\n            this.cameraHeight = camera.height\n\n            // helps sync up scaled surfaces with unscaled\n            if (this.surface.oneToOne && camera.scale > 1) {\n               this.zScaleHack = 1\n            }\n         }\n\n         this.settingsDefault()\n      }\n\n      debugReset() {\n         this.debug = {\n            spritesSkipped: this.debug.spritesSkippedCount,\n            spritesDrawn: this.debug.spritesDrawnCount,\n            rectanglesSkipped: this.debug.rectanglesSkippedCount,\n            rectanglesDrawn: this.debug.rectanglesDrawnCount,\n            shapesSkipped: this.debug.shapesSkippedCount,\n            shapesDrawn: this.debug.shapesDrawnCount,\n            circlesSkipped: this.debug.circlesSkippedCount,\n            circlesDrawn: this.debug.circlesDrawnCount,\n            spritesSkippedCount: 0,\n            spritesDrawnCount: 0,\n            rectanglesSkippedCount: 0,\n            rectanglesDrawnCount: 0,\n            shapesSkippedCount: 0,\n            shapesDrawnCount: 0,\n            circlesSkippedCount: 0,\n            circlesDrawnCount: 0,\n         }\n      }\n\n      outside(o) {\n         return (\n            o.x + o.width < this.cameraX ||\n            o.x > this.cameraX + this.cameraWidth ||\n            o.y + o.height < this.cameraY ||\n            o.y > this.cameraY + this.cameraHeight\n         )\n      }\n\n      sprite(options) {\n         var scale = this.scale\n         var info = this.cs.sprite.info(options)\n         var frame = info.frame\n         var xOff = info.xoff\n         var yOff = info.yoff\n\n         // dest\n         var dx = options.x - this.cameraX\n         var dy = options.y - this.cameraY\n         var dWidth = info.width\n         var dHeight = info.height\n\n         // source\n         var sx = 0\n         var sy = 0\n         var sWidth = info.fWidth\n         var sHeight = info.fHeight\n\n         // trimming\n         if (options.hTrim) {\n            sHeight -= options.hTrim\n            dHeight -= options.hTrim\n         }\n\n         // when flipping match the pixel\n         if (info.scaleX < 0 && xOff) dx++\n         if (info.scaleY < 0 && yOff) dy++\n\n         var rotateOrSomething = (info.scaleX < 0 || info.scaleY < 0 || info.angle)\n         if (rotateOrSomething) {\n            this.surface.ctx.save()\n            this.surface.ctx.translate((dx * scale), (dy * scale))\n            this.surface.ctx.rotate(options.angle * Math.PI / 180)\n            this.surface.ctx.scale(info.scaleX, info.scaleY)\n\n            this.surface.ctx.drawImage(\n               frame,\n               sx, sy, sWidth, sHeight,\n               (-xOff * scale),\n               (-yOff * scale + this.zScaleHack),\n               (dWidth * scale),\n               (dHeight * scale)\n            )\n\n            this.surface.ctx.restore()\n         } else {\n            this.surface.ctx.drawImage(\n               frame,\n               sx, sy, sWidth, sHeight,\n               ((dx - xOff) * scale),\n               ((dy - yOff) * scale) + this.zScaleHack,\n               (dWidth * scale),\n               (dHeight * scale)\n            )\n         }\n\n         this.debug.spritesDrawnCount += 1\n         this.settingsDefault()\n         return\n      }\n\n      textInfo(options) {\n         // Guessing the size\n         var lines = []\n         var curLine = []\n         var y = 0\n         var x = 0\n         var textArr = (options.text.toString()).split('')\n\n         // Setup the lines\n         for (var pos in textArr) {\n            curLine.push(textArr[pos])\n\n            if (this.surface.ctx.measureText(curLine.join('')).width > options.width) {\n               // Try to find a space\n               for (var o = curLine.length; o > 0; o--)\n                  if (curLine[o] == ' ') break\n\n               // If no space add a dash\n               if (!o) {\n                  o = curLine.length - 2\n                  curLine.splice(o - 1, 0, '-')\n               }\n\n               // Draw and reset\n               lines.push(curLine.slice(0, o).join('').trim())\n               curLine = curLine.slice(o, curLine.length)\n               y += options.lineHeight\n            }\n            if (pos == textArr.length - 1) {\n               lines.push(curLine.join('').trim())\n            }\n         }\n\n         return {\n            lines: lines,\n            lineHeight: options.lineHeight,\n            width: options.width,\n            height: lines.length * options.lineHeight,\n         }\n      }\n\n      text(options) {\n         var x = options.x - this.cameraX\n         var y = options.y - this.cameraY\n         var scale = this.scale\n\n         options.center && this.cs.draw.setTextCenter()\n\n         if (options.lines) {\n            for (var line in options.lines) {\n               var lineYOffset = (line * (options.lineHeight || this.surface.ctx.lineHeight))\n               this.surface.ctx.fillText(\n                  options.lines[line],\n                  x * scale,\n                  (y + lineYOffset) * scale\n               )\n            }\n         } else {\n            this.surface.ctx.fillText(\n               options.text,\n               Math.floor(x * scale),\n               Math.floor(y * scale)\n            )\n         }\n         this.settingsDefault()\n      }\n\n      textWidth(str) {\n         return this.surface.ctx.measureText(str).width\n      }\n\n      line(options) {\n         var lineWidth = this.surface.ctx.lineWidth\n         var lineWidthAdjust = lineWidth / 2 / this.scale\n         var scale = this.scale\n\n         var x1 = options.points[0].x + lineWidthAdjust - this.cameraX\n         var x2 = options.points[1].x + lineWidthAdjust - this.cameraX\n         var y1 = options.points[0].y - lineWidthAdjust - this.cameraY\n         var y2 = options.points[1].y - lineWidthAdjust - this.cameraY\n\n         this.surface.ctx.beginPath();\n         this.surface.ctx.moveTo(x1 * scale, y1 * scale);\n         this.surface.ctx.lineTo(x2 * scale, y2 * scale);\n         this.surface.ctx.stroke()\n         this.settingsDefault()\n      }\n\n      fillRect(args) {\n         // console.log('drawing', args)\n         var scale = this.scale\n         var x = args.x\n         var y = args.y\n         var width = this.cs.default(args.width, args.size)\n         var height = this.cs.default(args.height, args.size)\n\n         if (args.center) {\n            x -= width / 2\n            y -= height / 2\n         }\n\n         if (this.outside({ x: x, y: y, width: width, height: height })) {\n            this.debug.rectanglesSkippedCount += 1\n            this.settingsDefault()\n            return\n         } else {\n            this.debug.rectanglesDrawnCount += 1\n         }\n\n         this.surface.ctx.fillRect(\n            (x - this.cameraX) * scale,\n            (y - this.cameraY) * scale,\n            width * scale,\n            height * scale,\n         )\n         this.settingsDefault()\n      }\n\n      strokeRect(args) {\n         var scale = this.scale\n         var lineWidth = this.surface.ctx.lineWidth\n         var lineWidthAdjust = lineWidth / 2 / scale\n\n         var x = args.x + lineWidthAdjust\n         var y = args.y + lineWidthAdjust\n         var width = this.cs.default(args.width, args.size) - lineWidthAdjust * 2\n         var height = this.cs.default(args.height, args.size) - lineWidthAdjust * 2\n\n         if (args.center) {\n            x -= width / 2\n            y -= height / 2\n         }\n\n         if (this.outside({ x: x, y: y, width: width, height: height })) {\n            this.debug.rectanglesSkippedCount += 1\n            this.settingsDefault()\n            return\n         } else {\n            this.debug.rectanglesDrawnCount += 1\n         }\n\n         this.surface.ctx.strokeRect(\n            (x - this.cameraX) * scale,\n            (y - this.cameraY) * scale,\n            width * scale,\n            height * scale,\n         )\n\n         this.settingsDefault()\n      }\n\n      circle(options) {\n         var scale = this.scale\n         var x = options.pos ? options.pos.x : options.x\n         var y = options.pos ? options.pos.y : options.y\n         var radius = options.radius\n\n         if (this.outside({\n            x: x - radius,\n            y: y - radius,\n            width: radius * 2,\n            height: radius * 2,\n         })) {\n            this.debug.circlesSkippedCount += 1\n            this.settingsDefault()\n            return\n         } else {\n            this.debug.circleDrawnCount += 1\n         }\n\n         var fill = this.cs.default(options.fill, false)\n         this.surface.ctx.beginPath()\n         this.surface.ctx.arc(\n            (x - this.cameraX) * scale,\n            (y - this.cameraY) * scale,\n            radius * scale,\n            0, Math.PI * 2, true\n         )\n         this.surface.ctx.closePath()\n         fill ? this.surface.ctx.fill() : this.surface.ctx.stroke()\n         this.settingsDefault()\n      }\n\n      circleGradient(options) {\n         var scale = this.scale\n         var x = options.x - this.cameraX\n         var y = options.y - this.cameraY\n         var radius = options.radius\n         var colorStart = options.colorStart\n         var colorEnd = options.colorEnd\n\n         var g = this.surface.ctx.createRadialGradient(\n            x * scale,\n            y * scale,\n            0,\n            x * scale,\n            y * scale,\n            radius * scale\n         )\n         g.addColorStop(1, colorEnd)\n         g.addColorStop(0, colorStart)\n         this.surface.ctx.fillStyle = g\n         this.surface.ctx.beginPath()\n         this.surface.ctx.arc(\n            x * scale,\n            y * scale,\n            radius * scale,\n            0, Math.PI * 2, true\n         )\n         this.surface.ctx.closePath()\n         this.surface.ctx.fill()\n         this.settingsDefault()\n      }\n\n      shape(options) {\n         var scale = this.scale\n         var vertices = options.vertices\n         var relative = this.cs.default(options.relative, { x: 0, y: 0 })\n\n         var bounds = { xmin: 0, ymin: 0, xmax: 0, ymax: 0 }\n         for (var i = 0; i < vertices.length; i++) {\n            bounds.xmin = Math.min(relative.x + vertices[i].x, bounds.xmin)\n            bounds.ymin = Math.min(relative.y + vertices[i].y, bounds.ymin)\n            bounds.xmax = Math.max(relative.x + vertices[i].x, bounds.xmax)\n            bounds.ymax = Math.max(relative.y + vertices[i].y, bounds.ymax)\n         }\n\n         if (this.outside({\n            x: bounds.xmin,\n            y: bounds.ymin,\n            width: bounds.xmax - bounds.xmin,\n            height: bounds.ymax - bounds.ymin\n         })) {\n            this.debug.shapesSkippedCount += 1\n            this.settingsDefault()\n            return\n         } else {\n            this.debug.shapesDrawnCount += 1\n         }\n\n\n         this.surface.ctx.beginPath()\n         this.surface.ctx.moveTo(\n            (relative.x + vertices[0].x - this.cameraX) * scale,\n            (relative.y + vertices[0].y - this.cameraY) * scale\n         )\n\n         for (var i = 1; i < vertices.length; i++) {\n            this.surface.ctx.lineTo(\n               (relative.x + vertices[i].x - this.cameraX) * scale,\n               (relative.y + vertices[i].y - this.cameraY) * scale\n            )\n         }\n\n         this.surface.ctx.closePath(\n            (relative.x + vertices[0].x - this.cameraX) * scale,\n            (relative.y + vertices[0].y - this.cameraY) * scale\n         )\n\n         !options.fill && this.surface.ctx.stroke()\n         options.fill && this.surface.ctx.fill()\n         this.settingsDefault()\n      }\n\n      setColor(color) {\n         if(this.surface.ctx.fillStyle === color && this.surface.ctx.strokeStyle === color) return\n         this.surface.ctx.fillStyle = color;\n         this.surface.ctx.strokeStyle = color;\n      }\n\n      setAlpha(alpha) {\n         if(this.surface.ctx.globalAlpha === alpha) return\n         this.surface.ctx.globalAlpha = alpha;\n      }\n\n      setWidth(width) {\n         if(this.surface.ctx.lineWidth === width * this.scale) return\n         this.surface.ctx.lineWidth = width * this.scale;\n      }\n\n      setFont(options) {\n         if(this.surface.ctx.fontSize === options.size * this.scale && this.surface.ctx.fontFamily === options.family) return\n         this.surface.ctx.fontSize = options.size * this.scale\n         this.surface.ctx.fontFamily = options.family\n         this.surface.ctx.font = (options.effect ? options.effect + ' ' : '') + options.size * this.scale + 'px ' + options.family;\n      }\n\n      setLineHeight(height) {\n         if(this.surface.ctx.lineHeight === height) return\n         this.surface.ctx.lineHeight = height\n      }\n\n      setLineDash(lineDash) {\n         this.surface.ctx.setLineDash(lineDash)\n      }\n\n      setTextAlign(alignment) {\n         if(this.surface.ctx.textAlign === alignment) return\n         this.surface.ctx.textAlign = alignment;\n      }\n\n      setTextBaseline(alignment) {\n         if(this.surface.ctx.textBaseline === alignment) return\n         this.surface.ctx.textBaseline = alignment;\n      }\n\n      setTextCenter() {\n         this.setTextAlign('center');\n         this.setTextBaseline('middle');\n      }\n\n      setOperation(operation) {\n         if(this.surface.ctx.globalCompositeOperation === operation) return\n         this.surface.ctx.globalCompositeOperation = operation;\n      }\n\n      settings(settings) {\n         for (var setting in settings) {\n            this.config.current[setting] = settings[setting]\n         }\n         this.settingsUpdate()\n      }\n\n      default(settings) {\n         for (var setting in settings) {\n            this.config.defaults[setting] = settings[setting]\n         }\n         this.settingsDefault()\n      }\n\n      settingsUpdate() {\n         this.setAlpha(this.config.current.alpha)\n         this.setWidth(this.config.current.width)\n         this.setFont(this.config.current.font)\n         this.setTextAlign(this.config.current.textAlign)\n         this.setLineHeight(this.config.current.lineHeight)\n         this.setTextBaseline(this.config.current.textBaseline)\n         this.setColor(this.config.current.color)\n         this.setOperation(this.config.current.operation)\n         this.setLineDash(this.config.current.lineDash)\n      }\n\n      settingsDefault() {\n         for (var setting in this.config.defaults) {\n            this.config.current[setting] = this.config.defaults[setting]\n         }\n\n         this.settingsUpdate()\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_DRAW\n      : cs.draw = new CSENGINE_DRAW(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: FPS |---------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_FPS {\n      constructor(cs) {\n         this.cs = cs\n\n         this.rate = 0\n         this.frame = 0\n         this.check = Date.now()\n      }\n\n      update() {\n         this.checkReset() ? this.frame += 1 : this.reset()\n      }\n\n      checkReset() {\n         return Date.now() - this.check < 1000\n      }\n\n      reset() {\n         this.check = Date.now()\n         this.rate = this.frame\n         this.frame = 0\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_FPS\n      : cs.fps = new CSENGINE_FPS(cs)\n})()\n","//----------------------------------------------------------------------------//\n//--------------------------| CS ENGINE: FULLSCREEN |-------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_FULLSCREEN {\n      constructor(cs) {\n         this.cs = cs\n      }\n\n      possible() {\n         return this.normalize('possible')\n      }\n\n      is() {\n         return this.normalize('element') ? true : false\n      }\n\n      toggle() {\n         if (this.possible()) {\n            this.normalize('element')\n               ? this.exit()\n               : this.enter()\n         }\n      }\n\n      enter() {\n         this.possible() && this.normalize('request')\n      }\n\n      exit() {\n         this.possible() && this.normalize('exit')\n      }\n\n      normalize(func) {\n         for (var prefix of [undefined, 'moz', 'webkit']) {\n            var requestFullscreen = prefix + 'RequestFullscreen'\n            var fullscreenElement = prefix + 'FullscreenElement'\n            var fullscreenEnabled = prefix + 'FullscreenEnabled'\n            var exitFullscreen = prefix + 'ExitFullscreen'\n\n            if (!prefix) {\n               requestFullscreen = 'requestFullscreen'\n               fullscreenElement = 'fullscreenElement'\n               fullscreenEnabled = 'fullscreenEnabled'\n               exitFullscreen = 'exitFullscreen'\n            }\n\n            if (document.documentElement[requestFullscreen] !== undefined) {\n               if (func == 'possible') return document.documentElement[requestFullscreen] ? true : false\n               if (func == 'element') return document[fullscreenElement]\n               if (func == 'exit') return document[exitFullscreen]()\n               if (func == 'request') return document.documentElement[requestFullscreen]()\n               if (func == 'enabled') return document[fullscreenEnabled]\n            }\n         }\n\n         return undefined\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_FULLSCREEN\n      : cs.fullscreen = new CSENGINE_FULLSCREEN(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------| CS ENGINE: INPUT KEYBOARD |-----------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_INPUT_KEYBOARD {\n      constructor(cs) {\n         this.cs = cs\n\n         this.upList = {}\n         this.downList = {}\n         this.heldList = {}\n         this.events = []\n      }\n\n      addEvent(keyCode, eventType) {\n         var num = this.events.length\n         this.events[num] = {\n            event: eventType,\n            key: keyCode\n         }\n      }\n\n      execute() {\n         for (var i = 0; i < this.events.length; i++) {\n            var event = this.events[i].event;\n            var key = this.events[i].key\n            this.processEvent(key, event)\n         }\n         this.events = [];\n      }\n\n      processEvent(keyCode, type) {\n         if (type == 'up') {\n            if(!this.heldList[keyCode]) return\n            this.upList[keyCode] = performance.now()\n            return\n         }\n\n         this.downList[keyCode] = performance.now()\n         this.heldList[keyCode] = performance.now()\n      }\n\n      reset() {\n         for (var tmp in this.downList) {\n            this.downList[tmp] = false\n            if (this.upList[tmp]) {\n               this.heldList[tmp] = false\n            }\n\n            this.upList[tmp] = false\n         }\n      }\n\n      blur() {\n         for (var keyId in this.downList) {\n            this.downList[keyId] = false\n            this.heldList[keyId] = false\n            this.upList[keyId] = false\n         }\n\n         this.events = []\n      }\n\n      eventDown(keyEvent) {\n         keyEvent.preventDefault();\n         if (!keyEvent.repeat) {\n            this.virtualDown(keyEvent.keyCode);\n         }\n      }\n\n      eventUp(keyEvent) {\n         this.virtualUp(keyEvent.keyCode);\n      }\n\n      virtualDown(keyCode) {\n         this.addEvent(keyCode, 'down');\n      }\n\n      virtualUp(keyCode) {\n         this.addEvent(keyCode, 'up');\n      }\n\n      virtualPress(key) {\n         this.virtualDown(key);\n         this.virtualUp(key);\n      }\n\n      up(keyID) {\n         return this.upList[keyID] || false\n      }\n\n      down(keyID) {\n         return this.downList[keyID] || false\n      }\n\n      held(keyID) {\n         return this.heldList[keyID] || false\n      }\n\n      isUp(keyID) {\n         return this.upList[keyID] ? true : false\n      }\n\n      isDown(keyID) {\n         return this.downList[keyID] ? true : false\n      }\n\n      isHeld(keyID) {\n         return this.heldList[keyID] ? true : false\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_INPUT_KEYBOARD\n      : cs.inputKeyboard = new CSENGINE_INPUT_KEYBOARD(cs)\n})()\n","//----------------------------------------------------------------------------//\n//--------------------------| CS ENGINE: INPUT MOUSE |------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_INPUT_MOUSE {\n      constructor(cs) {\n         this.cs = cs\n\n         this.x = undefined\n         this.y = undefined\n      }\n\n      pos() {\n         var convert = this.cs.inputTouch.convertToGameCords(this.x, this.y)\n         return (cs.draw.raw)\n            ? { x: this.x, y: this.y }\n            : { x: convert.x, y: convert.y }\n      }\n\n      eventDown(e) {\n         this.cs.inputTouch.touchUse(-1)\n         this.x = e.clientX\n         this.y = e.clientY\n\n         this.cs.inputTouch.eventsDownMove.push({\n            type: 'down',\n            id: -1,\n            x: this.x,\n            y: this.y\n         })\n\n         this.eventMove(e)\n      }\n\n      eventMove(e) {\n         this.x = e.clientX\n         this.y = e.clientY\n\n         this.cs.inputTouch.eventsDownMove.push({\n            type: 'move',\n            id: -1,\n            x: this.x,\n            y: this.y\n         })\n      }\n\n      eventUp(e) {\n         this.cs.inputTouch.eventsUp.push({\n            type: 'up',\n            id: -1\n         })\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_INPUT_MOUSE\n      : cs.inputMouse = new CSENGINE_INPUT_MOUSE(cs)\n})()\n","//----------------------------------------------------------------------------//\n//--------------------------| CS ENGINE: INPUT TOUCH |------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_INPUT_TOUCH {\n      constructor(cs) {\n         this.cs = cs\n         this.eventsDownMove = []\n         this.eventsUp = []\n         this.list = [\n            { id: -1, x: undefined, y: undefined, used: false } // mouse\n         ]\n\n         this.eventFunctions = {\n            down: this.eventFunctionDown.bind(this),\n            move: this.eventFunctionMove.bind(this),\n            up: this.eventFunctionUp.bind(this),\n         }\n      }\n\n      batchDownMove() {\n         while(this.eventsDownMove.length) {\n            var event = this.eventsDownMove.shift()\n            this.eventFunctions[event.type](event)\n         }\n      }\n\n      batchUp() {\n         while(this.eventsUp.length) {\n            var event = this.eventsUp.shift()\n            this.eventFunctions[event.type](event) // ok.... -.O\n         }\n      }\n\n      eventFunctionDown(vEvent) {\n         this.touchUse(vEvent.id)\n      }\n\n      eventFunctionUp(vEvent) {\n         this.touchUnuse(vEvent.id)\n      }\n\n      eventFunctionMove(vEvent) {\n         this.touchUpdate({\n            id: vEvent.id,\n            x: vEvent.x,\n            y: vEvent.y\n         })\n      }\n\n      // modern pointers\n      eventPointerDown(e) {\n         e.preventDefault()\n\n         this.eventsDownMove.push({\n            type: 'down',\n            id: e.pointerId,\n            x: e.clientX,\n            y: e.clientY\n         })\n\n         this.eventPointerMove(e)\n      }\n\n      eventPointerMove(e) {\n         e.preventDefault()\n\n         this.cs.inputMouse.x = e.clientX\n         this.cs.inputMouse.y = e.clientY\n\n         this.eventsDownMove.push({\n            type: 'move',\n            id: e.pointerId,\n            x: e.clientX,\n            y: e.clientY\n         })\n      }\n\n      eventPointerUp(e) {\n         e.preventDefault()\n\n         this.eventsUp.push({\n            type: 'up',\n            id: e.pointerId,\n            x: e.clientX,\n            y: e.clientY\n         })\n      }\n\n      // old touch\n      eventTouchDown(e) {\n         e.preventDefault()\n\n         for (var touch of e.changedTouches) {\n            this.eventsDownMove.push({\n               type: 'down',\n               id: touch.identifier,\n               x: touch.clientX,\n               y: touch.clientY\n            })\n\n            this.eventTouchMove(e)\n         }\n      }\n\n      eventTouchMove(e) {\n         e.preventDefault()\n\n         for (var touch of e.changedTouches) {\n            this.eventsDownMove.push({\n               type: 'move',\n               id: touch.identifier,\n               x: touch.clientX,\n               y: touch.clientY\n            })\n         }\n      }\n\n      eventTouchUp(e) {\n         e.preventDefault()\n\n         for (var touch of e.changedTouches) {\n            this.eventsUp.push({\n               type: 'up',\n               id: touch.identifier,\n               x: touch.clientX,\n               y: touch.clientY\n            })\n         }\n      }\n\n      touchUse(id) {\n         // reuse from list or add to end\n         for (var i = 0; i < this.list.length; i++) {\n            var touch = this.list[i]\n            if (!touch.used && !touch.new) break\n         }\n\n         this.list[i] = {\n            id: id,\n            used: false,\n            new: true,\n            down: true,\n            held: true,\n            up: false,\n            x: undefined,\n            y: undefined\n         }\n      }\n\n      touchUnuse(id) {\n         var touch = this.list.find(function(t) { return t.id == id })\n         if (!touch) {\n            return\n         }\n\n         touch.used = false\n         touch.held = false\n         touch.up = true\n      }\n\n      touchUpdate(eTouch) {\n         var touch = this.list.find(function(t) { return t.id == eTouch.id })\n         if (!touch) return\n\n\n         touch.x = eTouch.x / this.cs.width * this.cs.clampWidth\n         touch.y = eTouch.y / this.cs.height * this.cs.clampHeight\n      }\n\n      observer(useGameCords) {\n         return {\n            parent: this,\n            touch: undefined,\n            observing: false,\n            useGameCords: useGameCords,\n            down: false,\n            held: false,\n            up: false,\n            x: 0,\n            y: 0,\n            offsetX: 0,\n            offsetY: 0,\n            check: function(area) {\n               this.observing ?\n                  this.observe() :\n                  this.findTouchToObserve(area)\n            },\n            uncheck: function() {\n               this.observing = false\n            },\n            observe: function() {\n               // im observing. lets update my values\n               if (this.observing) {\n                  this.x = this.touch.x\n                  this.y = this.touch.y\n\n                  if (this.useGameCords) {\n                     var convertedToGameCords = this.parent.convertToGameCords(this.x, this.y)\n                     this.x = convertedToGameCords.x\n                     this.y = convertedToGameCords.y\n                  }\n\n                  this.down = this.touch.down\n                  this.held = this.touch.held\n                  this.up = this.touch.up\n\n                  if (this.up) this.observing = false\n                  return\n               }\n            },\n            findTouchToObserve(area) {\n               // find a touch to observe\n               for (var touch of this.parent.list) {\n                  // this touch is being observed or not available to latch\n                  if (touch.used || !touch.down) continue\n\n                  var touchX = touch.x\n                  var touchY = touch.y\n                  if (this.useGameCords) {\n                     var convertedToGameCords = this.parent.convertToGameCords(touchX, touchY)\n                     touchX = convertedToGameCords.x\n                     touchY = convertedToGameCords.y\n                  }\n\n                  // check if within\n                  if (\n                     touchX > area.x && touchX < area.x + (area.width || area.size) &&\n                     touchY > area.y && touchY < area.y + (area.height || area.size)\n                  ) {\n                     // observe this touch!\n                     touch.used = true\n\n                     // setup\n                     this.observing = true\n                     this.touch = touch\n                     // handy\n                     this.offsetX = touchX - area.x\n                     this.offsetY = touchY - area.y\n\n                     this.observe()\n                     break\n                  }\n               }\n            },\n            isDown: function() {\n               return this.touch && this.touch.down\n            },\n            isUp: function() {\n               return this.touch && this.touch.up\n            },\n            isHeld: function() {\n               return this.touch && this.touch.held\n            },\n            isWithin: function(rect) {\n               var width = this.parent.cs.default(rect.width, rect.size || 0)\n               var height = this.parent.cs.default(rect.height, rect.size || 0)\n\n               return (\n                  this.x > rect.x && this.x < rect.x + width &&\n                  this.y > rect.y && this.y < rect.y + height\n               )\n            }\n         }\n      }\n\n      reset() {\n         // up and down state only last one step\n         for (var touch of this.list) {\n            touch.down = false\n            touch.up = false\n            touch.new = false\n         }\n      }\n\n      convertToGameCords(x, y) {\n         var rect = this.cs.canvas.getBoundingClientRect();\n\n         var physicalViewWidth = rect.width\n         var physicalViewHeight = rect.height\n         var hortPercent = (x - rect.left) / physicalViewWidth\n         var vertPercent = (y - rect.top) / physicalViewHeight\n\n         var gamex = Math.round(hortPercent * (this.cs.camera.width / this.cs.camera.zoom))\n         var gamey = Math.round(vertPercent * (this.cs.camera.height / this.cs.camera.zoom))\n         gamex = (gamex) + this.cs.camera.x\n         gamey = (gamey) + this.cs.camera.y\n         return { x: gamex, y: gamey }\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_INPUT_TOUCH\n      : cs.inputTouch = new CSENGINE_INPUT_TOUCH(cs)\n})()\n","//----------------------------------------------------------------------------//\n//----------------------------| CS ENGINE: LOADER |---------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_LOADER {\n      constructor(cs) {\n         this.cs = cs\n\n         this.start = 0\n         console.log(cs, cs.assets)\n         this.loading =\n            cs.assets.sprites.length +\n            cs.assets.scripts.length +\n            cs.assets.sounds.length +\n            cs.assets.storages.length\n      }\n\n      load() {\n         if (!this.loading) {\n            return this.cs.setup.run()\n         }\n\n         this.start = Date.now()\n         console.groupCollapsed('Loading Assets...')\n\n         this.loadScripts()\n         this.loadSounds()\n         this.loadSprites()\n         this.loadStorages()\n      }\n\n      checkDone() {\n         this.loading -= 1\n         if (!this.loading) {\n            console.groupEnd()\n            const assetsLoadTime = Math.round(Date.now() - this.start)\n            console.log(`Assets Loaded in ${assetsLoadTime}ms`)\n            this.cs.setup.run()\n         }\n      }\n\n      loadScripts() {\n         for (const script of this.cs.assets.scripts) {\n            console.log(`Loading Script: ${script.path}`)\n            const htmlScript = document.createElement('script')\n            htmlScript.src = `${script.path}.js?v=${this.version}`\n            htmlScript.onload = this.checkDone.bind(this)\n            document.body.appendChild(htmlScript)\n         }\n      }\n\n      loadSprites() {\n         for (const sprite of this.cs.assets.sprites) {\n            cs.sprites.push(sprite)\n            console.log(`Loading Sprite: ${sprite.path}`)\n            sprite.html = document.createElement('img')\n            sprite.html.src = sprite.path + '.png?v=' + this.version\n            sprite.html.onload = this.checkDone.bind(this)\n         }\n      }\n\n      loadSounds() {\n         for (const sound of this.cs.assets.sounds) {\n            this.cs.sounds.push(sound)\n            console.log(`Loading Sound: ${sound.path}`)\n            sound.loaded = false\n            sound.src = sound.path + '.wav?v=' + this.version\n            sound.buffer = null\n            sound.request = new XMLHttpRequest()\n\n            sound.request.open('GET', sound.src, true);\n            sound.request.responseType = 'arraybuffer';\n\n            sound.request.onload = (data) => {\n               window.AudioContext = window.AudioContext || window.webkitAudioContext\n               if (window.AudioContext) {\n                  new AudioContext().decodeAudioData(data.currentTarget.response, function(buffer) {\n                     sound.buffer = buffer\n                  })\n               }\n               this.checkDone()\n            }\n            sound.request.send()\n         }\n      }\n\n      loadStorages() {\n         for (const storage of this.cs.assets.storages) {\n            this.cs.storages.push(storage)\n            storage.data = {}\n\n            // attempt to use localstorage\n            if (!storage.path) {\n               storage.data = JSON.parse(window.localStorage.getItem(storage.location))\n               this.checkDone()\n            }\n\n            // fetch the storage .json\n            if (storage.path) {\n               var that = this\n               storage.request = new XMLHttpRequest()\n               storage.request.onreadystatechange = function() {\n                  if (this.readyState == 4) {\n                     var data = JSON.parse(this.responseText)\n                     storage.data = data\n                     this.checkDone()\n                  }\n               }\n               storage.request.open(\"GET\", './' + storage.path + '.json?v=' + this.version, true)\n               storage.request.send()\n            }\n         }\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_LOADER\n      : cs.loader = new CSENGINE_LOADER(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: LOOP |---------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_LOOP {\n      constructor(cs) {\n         this.cs = cs\n\n         this.run = false\n         this.endSteps = []\n         this.beforeSteps = []\n         this.speed = 1000 / 60\n         this.last = Date.now()\n         this.id = 0\n         this.timeout = undefined\n      }\n\n      step(once) {\n         this.id += 1\n\n         // delta fixing\n         var now = Date.now()\n         this.delta = (now - this.last) / this.speed\n         this.last = now\n\n         if (!this.run || once) return\n         this.timeout = setTimeout(() => this.step(), this.speed)\n\n         this.cs.fps.update()\n         this.cs.draw.debugReset()\n         this.cs.network.read()\n\n         // move camera before clear\n         this.cs.camera.update()\n         this.cs.surface.clearAll()\n         this.cs.object.addNewObjects()\n\n         // input\n         this.cs.inputKeyboard.execute()\n         this.cs.inputTouch.batchDownMove()\n\n         // Execute before steps\n         // disconnect to allow adding within a beforestep\n         var temporaryBeforeSteps = []\n         while(this.beforeSteps.length){ temporaryBeforeSteps.push(this.beforeSteps.pop()) }\n         while (temporaryBeforeSteps.length) { temporaryBeforeSteps.pop()() }\n\n         this.cs.userStep && this.cs.userStep({ cs })\n\n         this.cs.object.loop((object) => {\n            if (!object.core.active || !object.core.live) return\n            var stepEvent = this.cs.objects[object.core.type].step\n            stepEvent && stepEvent({ object, cs: this.cs })\n         })\n\n         this.cs.userDraw && this.cs.userDraw({ cs })\n\n         this.cs.object.loop((object) => {\n            if (!object.core.active || !object.core.live) return\n            var template = this.cs.objects[object.core.type]\n            var drawFunction = template.draw\n            var drawOnceFunction = template.drawOnce\n\n            var surface = this.cs.surface.list[object.core.surface]\n            this.cs.draw.setSurface(surface)\n\n            if (drawOnceFunction) {\n               if (surface.clear || !object.core.drawn) {\n                  object.core.drawn = true\n                  drawOnceEvent({ object, cs: this.cs })\n               }\n            }\n\n            drawFunction && drawFunction.call(object, { object, cs: this.cs })\n         })\n\n         // timers\n         this.cs.timer.loop()\n\n         // Touch / Keyboard\n         this.cs.inputKeyboard.reset()\n         this.cs.inputTouch.reset()\n         this.cs.inputTouch.batchUp()\n\n         this.cs.surface.displayAll()\n\n         // Execute next steps\n         while (this.endSteps.length) {\n            this.endSteps.pop()()\n         }\n\n         // could clearup !live objects here\n         this.cs.object.clean()\n\n         // network metrics\n         if (this.cs.network.status) {\n            this.cs.network.updateMetrics()\n         }\n      }\n\n      beforeStep(func) {\n         this.beforeSteps.push(func)\n      }\n\n      endStep(func) {\n         this.endSteps.push(func)\n      }\n\n      start() {\n         this.run = true\n         this.step()\n      }\n\n      stop() {\n         this.run = false\n         clearTimeout(this.timeout)\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_LOOP\n      : cs.loop = new CSENGINE_LOOP(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: MATH |---------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_MATH {\n      constructor(cs) {\n         this.cs = cs\n      }\n\n      sign(number) {\n         if (!number) return 0\n         return number < 0 ? -1 : 1\n      }\n\n      between(num, min, max) {\n         return num >= Math.min(min, max) && num <= Math.max(min, max)\n      }\n\n      outside(num, min, max) {\n         return num < Math.min(min, max) || num > Math.max(min, max)\n      }\n\n      randomRange(min, max) {\n         return (min + Math.random() * (max-min))\n      }\n\n      iRandomRange(min, max) {\n         return Math.round(this.randomRange(min, max))\n      }\n\n      choose(array) {\n         return array[this.iRandomRange(0, array.length - 1)]\n      }\n\n      chooseRatio(ratios) {\n         // ratios = { \"50\": \"Choice1\", \"100\": \"Choice2\" }\n         var random = Math.random() * 100\n         for (var ratio in ratios) {\n            if (parseInt(ratio) > random) {\n               return ratios[ratio]\n            }\n         }\n         return ratios[ratio]\n      }\n\n      brakingDistance(options) {\n         return (Math.abs(options.speed) * options.friction) / (1 - options.friction)\n      }\n\n      requiredSpeed(options) {\n         return Math.sqrt(2 * options.friction * options.distance);\n      }\n\n      inRange(options) {\n         return options.num > options.min && options.num < options.max\n      }\n\n      sin(angleInDegrees) {\n         return Math.sin((angleInDegrees-90) * Math.PI/180)\n      }\n\n      cos(angleInDegrees) {\n         return Math.cos((angleInDegrees-90) * Math.PI/180)\n      }\n\n      degrees(radians) {\n         return radians * (180/Math.PI)\n      }\n\n      radians(degree) {\n\n      }\n\n      distance(p1, p2) {\n         // a^2 + b^2 = c^2\n         var a2 = (p1.x - p2.x) * (p1.x - p2.x)\n         var b2 = (p1.y - p2.y) * (p1.y - p2.y)\n\n         return Math.sqrt(a2 + b2)\n      }\n\n      direction(p1, p2) {\n         if (p2 == undefined) {\n            p2 = p1\n            p1 = { x: 0, y: 0 }\n         }\n\n         var xOff = p2.x - p1.x\n         var yOff = p2.y - p1.y\n         var beforeTurn = this.degrees(Math.atan2(xOff, -yOff)) + 180\n         var afterTurn = beforeTurn + 180\n         if (afterTurn > 360) {\n            afterTurn -= 360\n         }\n         return afterTurn\n      }\n\n      shortestDirection(d1, d2) {\n          var right = d2 - d1\n          if (right < 0) {\n              right = 360 + right\n          }\n\n          var left = d1 - d2\n          if (left < 0) {\n              left = 360 + left\n          }\n\n          return right > left ? -left : right\n      }\n\n      stepsToSeconds(steps, decimals) {\n         var decimals = this.cs.default(decimals, 1)\n         return Math.ceil(steps / (60) * decimals) / decimals\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_MATH\n      : cs.math = new CSENGINE_MATH(cs)\n})()\n","//----------------------------------------------------------------------------//\n//----------------------------| CS ENGINE: NETWORK |--------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_NETWORK {\n      constructor(cs) {\n         this.cs = cs\n\n         this.ws = {}\n         this.status = false\n         this.buffer = []\n\n         this.metrics = {\n            upNow: 0,\n            downNow: 0,\n            upAverage: 0,\n            downAverage: 0,\n            upTotal: 0,\n            downTotal: 0,\n            upWatch: 0,\n            downWatch: 0,\n            last: Date.now(),\n            count: 0\n         }\n\n         this.overrides = {\n            connect: function() {},\n            disconnect: function() {},\n            message: function() {},\n         }\n      }\n\n      updateMetrics() {\n         var metrics = cs.network.metrics\n         var now = Date.now()\n         if (now - metrics.last > 1000) {\n            metrics.count++\n            metrics.last = now\n            metrics.upNow = metrics.upWatch\n            metrics.downNow = metrics.downWatch\n            metrics.upTotal += metrics.upWatch\n            metrics.downTotal += metrics.downWatch\n            metrics.upAverage = metrics.upTotal / metrics.count\n            metrics.downAverage = metrics.downTotal / metrics.count\n\n            metrics.upWatch = 0\n            metrics.downWatch = 0\n         }\n      }\n\n      connect(options) {\n         // console.log('cs.network.connect', options)\n         try {\n            var host = options.host || window.location.host\n            if (options.ssl == undefined || options.ssl == false) {\n               var url = \"ws://\" + host + \":\" + options.port\n            } else {\n               var url = \"wss://\" + host + \":\" + options.port\n            }\n            var ws = new WebSocket(url);\n            ws.onopen = function() {\n               cs.network.onconnect()\n            }\n            ws.onclose = function() { cs.network.ondisconnect() }\n            ws.onmessage = function(event) { cs.network.onmessage(event.data) }\n            cs.network.ws = ws;\n         } catch(e) {\n            console.log(e);\n         }\n      }\n\n      isConnected() {\n         return cs.network.ws.readyState !== cs.network.ws.CLOSED\n      }\n\n      send(data) {\n         if (!this.status) return\n         if (typeof data !== 'string') {\n            data = JSON.stringify(data)\n         }\n         cs.network.metrics.upWatch += data.length\n         cs.network.ws.send(data)\n      }\n\n      read() {\n         while(this.buffer.length) {\n            var data = this.buffer.shift()\n            cs.network.metrics.downWatch += data.length\n            this.overrides.message(data)\n         }\n      }\n\n      onconnect() {\n         cs.network.status = true\n         this.overrides.connect()\n      }\n\n      ondisconnect() {\n         cs.network.status = false\n         this.overrides.disconnect()\n      }\n\n      onmessage(message) {\n         this.buffer.push(message)\n      }\n\n      setup(options) {\n         for (var optionName in options) {\n            cs.network.overrides[optionName] = options[optionName]\n         }\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_NETWORK\n      : cs.network = new CSENGINE_NETWORK(cs)\n})()\n","//----------------------------------------------------------------------------//\n//-----------------------------| CS ENGINE: OBJECT |--------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_OBJECT {\n      constructor(cs) {\n         this.cs = cs\n         this.list = [] // all objects\n         this.new = [] // newly added objects\n         this.unique = 0\n         this.types = {}\n         this.objGroups = {}\n         this.shouldClean = false\n      }\n\n      loop(call) {\n         var i = this.cs.object.list.length;\n         while (i--) {\n            var object = this.cs.object.list[i]\n            call(object)\n         }\n      }\n\n      create(options) {\n         if (!this.cs.objects[options.type]) {\n            console.log('object type \"' + options.type + '\" does not exist')\n            return undefined\n         }\n\n         var attr = options.attr\n         var template = this.cs.objects[options.type]\n         var zIndex = options.zIndex || template.zIndex || 0\n\n         // create the object\n         var newObj = {\n            core: {\n               zIndex: zIndex,\n               live: true,\n               active: true,\n               drawn: false,\n               type: options.type,\n               id: this.unique,\n               surface: this.cs.default(template.surface, 'game')\n            }\n         }\n\n         // predefined / custom Attr\n         for (var name in template.attr) { newObj[name] = template.attr[name] }\n         for (var name in attr) { newObj[name] = attr[name] }\n\n         // run create event\n         template.create && template.create.call(newObj, { object: newObj, cs: this.cs });\n\n         // add to list\n         this.new.push({ obj: newObj, zIndex: zIndex })\n         this.unique += 1\n\n         // grouping\n         if (!this.objGroups[options.type]) this.objGroups[options.type] = []\n         this.objGroups[options.type].push(newObj)\n\n         return newObj\n      }\n\n      addNewObjects() {\n         while (this.new.length) {\n            var obj = this.new.shift().obj\n            this.list.push(obj)\n         }\n\n         this.orderObjectsByZIndex()\n      }\n\n      orderObjectsByZIndex() {\n         this.order = this.list.sort(function(a, b) {\n            return b.core.zIndex === a.core.zIndex\n               ? b.core.id - a.core.id\n               : b.core.zIndex - a.core.zIndex\n         })\n      }\n\n      changeZIndex(object, zIndex) {\n         var listObject = object.list.find(function(listObject) {\n            return listObject.obj.core.id == object.core.id\n         })\n\n         listObject.core.zIndex = zIndex\n\n         this.orderObjectsByZIndex()\n      }\n\n      destroy(destroyObjOrID, fadeTimer) {\n         this.shouldClean = true\n         var destroyObj = (typeof destroyObjOrID === 'number')\n            ? this.id(destroyObjOrID)\n            : destroyObjOrID\n\n         destroyObj.core.live = false\n         destroyObj.core.active = false\n         destroyObj.core.fadeTimer = fadeTimer || 0\n\n         // remove from objGroup\n         var type = destroyObj.core.type\n         if (cs.objects[type].destroy) cs.objects[type].destroy.call(destroyObj)\n         this.objGroups[type] = this.objGroups[type].filter(function(obj) { return obj.core.live })\n      }\n\n      clean() {\n         if(!this.shouldClean) return\n         this.list = this.list.reduce(function(sum, num) {\n            if(num.core.live) sum.push(num)\n            return sum\n         }, [])\n      }\n\n      every() {\n         return this.list.concat(this.new.map(function(obj) { return obj.obj }))\n      }\n\n      all(type) {\n         return this.objGroups[type] || []\n      }\n\n      find(type) {\n         if (!this.objGroups[type]) {\n            return undefined\n         }\n         return this.objGroups[type][0]\n      }\n\n      search(call) {\n         return this.every().find(function(obj) {\n            if (!obj.core.live) return false\n            return call(obj)\n         })\n      }\n\n      id(id) {\n         return this.list.find(function(obj) { return obj.core.id === id })\n      }\n\n      count(type) {\n         return this.objGroups[type] ? this.objGroups[type].length : 0\n      }\n\n      reset() {\n         this.list = []\n         this.new = []\n         this.objGroups = {}\n         this.unique = 0\n      }\n\n      resize() {\n         for (var object of this.list) {\n            object.core.drawn = false\n         }\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_OBJECT\n      : cs.object = new CSENGINE_OBJECT(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: ROOM |---------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_ROOM {\n      constructor(cs) {\n         this.cs = cs\n\n         this.width = 100\n         this.height = 100\n         this.rect = {\n            x: 0,\n            y: 0,\n            width: 100,\n            height: 100\n         }\n      }\n\n      setup(info) {\n         this.width = info.width\n         this.height = info.height\n         if (info.background) cs.canvas.style.background = info.background\n         this.rect = { x: 0, y: 0, width: this.width, height: this.height }\n         this.cs.resize()\n      }\n\n      outside(rect) {\n         var width = this.cs.default(rect.width, 0)\n         var height = this.cs.default(rect.height, 0)\n\n         return (\n            rect.x < 0 ||\n            rect.y < 0 ||\n            rect.x + width > this.width ||\n            rect.y + height > this.height\n         )\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_ROOM\n      : cs.room = new CSENGINE_ROOM(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: SETUP |--------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_SETUP {\n      constructor(cs) {\n         this.cs = cs\n      }\n\n      run() {\n         // Initiate Inputs\n         this.cs.ctx = this.cs.canvas.getContext('2d')\n         this.cs.canvas.tabIndex = 1000\n         this.cs.canvas.style.outline = 'none'\n         this.cs.canvas.style.touchAction = 'none'\n\n         this.cs.canvas.addEventListener('click', () => {\n            this.cs.sound.enable()\n            this.cs.canvas.focus()\n         })\n\n         this.cs.canvas.addEventListener('keydown', (e) => this.cs.inputKeyboard.eventDown(e))\n         this.cs.canvas.addEventListener('keyup', (e) => this.cs.inputKeyboard.eventUp(e))\n\n         if (this.cs.canvas.setPointerCapture) {\n            this.cs.canvas.addEventListener(\"pointerdown\", (e) => this.cs.inputTouch.eventPointerDown(e))\n            this.cs.canvas.addEventListener(\"pointermove\", (e) => this.cs.inputTouch.eventPointerMove(e))\n            this.cs.canvas.addEventListener(\"pointerup\", (e) => this.cs.inputTouch.eventPointerUp(e))\n            this.cs.canvas.addEventListener(\"pointerout\", (e) => this.cs.inputTouch.eventPointerUp(e))\n         } else {\n            this.cs.canvas.addEventListener(\"touchstart\", (e) => this.cs.inputTouch.eventTouchDown(e))\n            this.cs.canvas.addEventListener(\"touchmove\", (e) => his.cs.inputTouch.eventTouchMove(e))\n            this.cs.canvas.addEventListener(\"touchend\", (e) => this.cs.inputTouch.eventTouchUp(e))\n\n            this.cs.canvas.addEventListener('mousedown', (e) => this.cs.inputMouse.eventDown(e))\n            this.cs.canvas.addEventListener('mousemove', (e) => this.cs.inputMouse.eventMove(e))\n            this.cs.canvas.addEventListener('mouseup', (e) => this.cs.inputMouse.eventUp(e))\n            this.cs.canvas.addEventListener('mouseout', (e) => this.cs.inputMouse.eventUp(e))\n         }\n\n         // View, Game and GUI surfaces\n         this.cs.surface.create({ name: 'gui', oneToOne: true, useCamera: false, depth: 0 })\n         this.cs.surface.create({ name: 'game', oneToOne: true, useCamera: true,  depth: 10 })\n\n         // Sound\n         //this.cs.sound.active = this.cs.sound.init();\n\n         // watch for resizing\n         this.cs.resize = () => {\n            var maxSize = this.cs.maxSize\n            this.cs.width = this.cs.canvas.clientWidth\n            this.cs.height = this.cs.canvas.clientHeight\n            this.cs.clampWidth = this.cs.width\n            this.cs.clampHeight = this.cs.height\n\n            if (this.cs.clampWidth > maxSize) {\n               this.cs.clampHeight = this.cs.clampHeight / this.cs.clampWidth * maxSize\n               this.cs.clampWidth = maxSize\n            }\n\n            if (this.cs.clampHeight > maxSize) {\n               this.cs.clampWidth = this.cs.clampWidth / this.cs.clampHeight * maxSize\n               this.cs.clampHeight = maxSize\n            }\n\n            this.cs.clampWidth = Math.ceil(this.cs.clampWidth)\n            this.cs.clampHeight = Math.ceil(this.cs.clampHeight)\n\n            this.cs.canvas.width = this.cs.clampWidth\n            this.cs.canvas.height = this.cs.clampHeight\n\n            this.cs.camera.resize()\n            this.cs.surface.resize()\n            this.cs.object.resize()\n         }\n\n         // Sprites/Storage/Sound\n         this.cs.sprite.init()\n         this.cs.storage.init()\n\n         // room/camera\n         this.cs.room.setup({\n            width: this.cs.canvas.getBoundingClientRect().width,\n            height: this.cs.canvas.getBoundingClientRect().height\n         })\n\n         this.cs.camera.setup({\n            width: this.cs.canvas.getBoundingClientRect().width,\n            height: this.cs.canvas.getBoundingClientRect().height\n         })\n\n         // window global functions\n         if (window) {\n            window.onerror = function(errorMsg, url, lineNumber) { this.cs.loop.stop() }\n\n            window.onfocus = function(e) {\n               this.cs.focus(true)\n            }\n\n            window.onblur = function(e) {\n               this.cs.focus(false)\n               this.cs.sound.toggleActive(false, e)\n               this.cs.inputKeyboard.blur()\n            }\n\n            window.onresize = this.cs.resize.bind(this)\n         }\n\n         // bootstrapping\n         this.cs.start({ cs: this.cs })\n         this.cs.resize()\n         this.cs.loop.start()\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_SETUP\n      : cs.setup = new CSENGINE_SETUP(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: SOUND |--------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_SOUND {\n      constructor(cs) {\n         this.cs = cs\n\n         this.list = {}\n         this.playList = []\n         this.initiated = false\n         this.context = undefined\n         this.canPlayAudio = false\n         this.mute = false\n         this.active = true\n         this.volume = undefined\n      }\n\n      enable() {\n         if (!this.initiated) this.init()\n         if (this.initiated && !this.canPlayAudio) return\n         if (!this.context) return\n\n         cs.sound.toggleActive(true)\n         var source = this.context.createBufferSource();\n         source.buffer = this.context.createBuffer(1, 1, 22050);\n         source.connect(this.context.destination);\n         source.start(0);\n      }\n\n      init() {\n         this.initiated = true\n         window.AudioContext = window.AudioContext || window.webkitAudioContext\n         if (window.AudioContext) {\n            this.context = new AudioContext()\n            this.canPlayAudio = true\n         }\n         this.loadSounds()\n      }\n\n      loadSounds() {\n         for (var sound of cs.sounds) {\n            var name = sound.name || sound.path.split('/').pop()\n            this.list[name] = sound\n         }\n      }\n\n      play(audioName, options) {\n         var sound = this.list[audioName]\n         if (this.canPlayAudio && sound) {\n            this.playList.forEach(function(audioObj) {\n               if (audioObj.name == audioName) {\n                  //console.log('Reuse this sound');\n               }\n            })\n            var csAudioObj = this.context.createBufferSource();\n            csAudioObj.name = audioName;\n            csAudioObj.buffer = sound.buffer;\n            for (var opt in options) { csAudioObj[opt] = options[opt] }\n            csAudioObj.gainNode = this.context.createGain();\n            csAudioObj.connect(csAudioObj.gainNode);\n            csAudioObj.gainNode.connect(this.context.destination);\n            csAudioObj.gainNode.gain.value = cs.sound.mute ? 0 : 1;\n            csAudioObj.start(0);\n            this.playList.push(csAudioObj);\n            return csAudioObj;\n         }\n         return undefined;\n      }\n\n      reset() {\n         for (var sound in this.playList) {\n            //TODO there is an error here take a look in a second I got to go wash my cloths~!!!\n            if (!this.playList) return;\n            this.playList[sound].stop();\n            this.playList[sound].disconnect();\n         }\n      }\n\n      toggleMute(bool) {\n         this.mute = bool;\n         (bool) ? this.setGain(0): this.setGain(1);\n      }\n\n      setGain(gainValue) {\n         console.log('GainValue: ' + gainValue);\n         for (var audioObj in this.playList) {\n            console.log('Muting...', audioObj);\n            this.playList[audioObj].gainNode.gain.value = gainValue;\n         }\n      }\n\n      toggleActive(bool) {\n         if (bool && !this.initiated) {\n            this.init()\n         }\n\n         if (this.context) {\n            this.context[bool ? 'resume' : 'suspend']()\n         }\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_SOUND\n      : cs.sound = new CSENGINE_SOUND(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: SPRITE |--------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_SPRITE {\n      constructor(cs) {\n         this.cs = cs\n         this.list = {}\n      }\n\n      init(sprites) {\n         for (var sprite of this.cs.sprites) {\n            this.initSprite(sprite)\n         }\n      }\n\n      initSprite(options) {\n         // create Sprite\n         var width = options.fwidth || options.html.width\n         var height = options.fheight || options.html.height\n         var newSprite = {\n            html: options.html,\n            name: options.name || options.path.split('/').pop(),\n            texture: document.createElement('canvas'),\n            frames: options.frames || 1,\n            fwidth: width,\n            fheight: height,\n            xoff: options.xoff || 0,\n            yoff: options.yoff || 0,\n            mask: {\n               width: options.mask ? (options.mask.width || width - (options.mask.left || 0) - (options.mask.right || 0)) : width,\n               height: options.mask ? (options.mask.height || height - (options.mask.top || 0) - (options.mask.bottom || 0)) : height\n            },\n            frames: []\n         }\n\n         // handle Frames\n         var dx = 0\n         var dy = 0\n\n         while (dx < newSprite.html.width && dy < newSprite.html.height) {\n            var frame = {}\n            frame.canvas = document.createElement('canvas')\n            frame.canvas.width = newSprite.fwidth\n            frame.canvas.height = newSprite.fheight\n            frame.canvas.ctx = frame.canvas.getContext('2d')\n\n            frame.canvas.ctx.drawImage(newSprite.html, dx, dy, newSprite.fwidth, newSprite.fheight,\n               0, 0, newSprite.fwidth, newSprite.fheight)\n            newSprite.frames.push(frame.canvas)\n\n            dx += newSprite.fwidth\n            if (dx === newSprite.html.width) {\n               dx = 0\n               dy += newSprite.fheight\n            }\n         }\n\n         this.cs.sprite.list[newSprite.name] = newSprite\n      }\n\n      texture(spriteName, width, height) {\n         var sprite = this.cs.sprite.list[spriteName]\n         sprite.texture = document.createElement('canvas')\n         sprite.texture.ctx = sprite.texture.getContext('2d')\n         sprite.texture.width = width\n         sprite.texture.height = height\n         sprite.texture.fwidth = width\n         sprite.texture.fheight = height\n\n         var x = 0\n         while (x < width) {\n            var y = 0\n            while (y < height) {\n               sprite.texture.ctx.drawImage(sprite.html, x, y);\n               y += sprite.html.height\n            }\n            x += sprite.html.width\n         }\n      }\n\n      info(options) {\n         // we need something to return info on sprites based on scale etc\n         var sprite = this.list[options.spr]\n         var frame = this.cs.default(options.frame, 0)\n         var scaleX = this.cs.default(options.scaleX, 1)\n         var scaleY = this.cs.default(options.scaleY, 1)\n         var width = this.cs.default(options.width, sprite.fwidth)\n         var height = this.cs.default(options.height, sprite.fheight)\n         var angle = this.cs.default(options.angle, 0)\n         var xoff = this.cs.default(options.xoff, sprite.xoff)\n         var yoff = this.cs.default(options.yoff, sprite.yoff)\n\n         if (options.size) {\n            var tall = height > width\n            var ratio = height / width\n\n            width = tall ? options.size / ratio : options.size\n            height = tall ? options.size : options.size * ratio\n         }\n\n         if (options.xCenter) xoff = width / 2\n         if (options.yCenter) yoff = height / 2\n         if (options.center) {\n            xoff = width / 2\n            yoff = height / 2\n         }\n\n         return {\n            name: options.spr,\n            fWidth: sprite.fwidth,\n            fHeight: sprite.fheight,\n            width: (options.texture ? sprite.texture.fwidth : width),\n            height: (options.texture ? sprite.texture.fheight : height),\n            scaleX: scaleX,\n            scaleY: scaleY,\n            angle: angle,\n            xoff: xoff,\n            yoff: yoff,\n            frames: options.texture ? [sprite.texture] : sprite.frames,\n            frame: sprite.frames[frame],\n            mask: {\n               width: sprite.mask.width,\n               height: sprite.mask.height\n            }\n         }\n      }\n\n      exists(name) {\n         return this.list[name] ? true : false\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n       ? module.exports = CSENGINE_SPRITE\n       : cs.sprite = new CSENGINE_SPRITE(cs)\n})()\n","//----------------------------------------------------------------------------//\n//-----------------------------| CS ENGINE: SURFACE |-------------------------//\n//----------------------------------------------------------------------------//\n/*\nTypes of surfaces\n   - GUI\n   - matches device pixels\n   - draw calls match pixels\n   - GAME\n   - matches device pixels\n   - draw calls will offset by camera\n   - MAP\n   - matches room size\n*/\n(() => {\n   class CSENGINE_SURFACE {\n      constructor(cs) {\n         this.cs = cs\n\n         this.list = {}\n         this.order = []\n         this.imageSmoothing = false\n      }\n\n      create(config) {\n         var num = this.list.length\n         var canvas = document.createElement(\"canvas\")\n\n         var oneToOne = this.cs.default(config.oneToOne, true)\n         var useCamera = this.cs.default(config.useCamera, true)\n         var drawOutside = this.cs.default(config.drawOutside, false)\n         var manualClear = this.cs.default(config.manualClear, false)\n\n         this.list[config.name] = {\n            name: config.name,\n            canvas: canvas,\n            ctx: canvas.getContext('2d'),\n            depth: this.cs.default(config.depth, 0),\n            width: 0,\n            height: 0,\n            scale: 1,\n            oneToOne: oneToOne,\n            useCamera: useCamera,\n            drawOutside: drawOutside,\n            manualClear: manualClear,\n            clearRequest: false,\n            clear: true\n         }\n\n         // Add and fix size\n         this.addToOrder(this.list[config.name])\n         this.resize()\n\n         // Return the element\n         return this.list[config.name]\n      }\n\n      addToOrder(surface) {\n         // Find Place to put it!\n         for (var i = 0; i < this.order.length; i++) {\n            if (this.order[i].depth > surface.depth) {\n               break\n            }\n         }\n\n         this.order.splice(i, 0, surface)\n      }\n\n      clearAll() {\n         this.cs.ctx.clearRect(0, 0, this.cs.canvas.width, this.cs.canvas.height)\n         for (var surface of this.order) {\n            if (!surface.manualClear || surface.clearRequest) {\n               var clearRect = { x: 0, y: 0, width: surface.canvas.width, height: surface.canvas.height }\n\n               if (surface.clearRequest)\n                  clearRect = surface.clearRequest\n\n               surface.ctx.clearRect(clearRect.x, clearRect.y, clearRect.width, clearRect.height)\n               surface.clearRequest = undefined\n               surface.clear = true\n               continue\n            }\n\n            surface.clear = false\n         }\n      }\n\n      clear(options) {\n         var surface = this.list[options.name]\n         surface.clearRequest = {\n            x: options.x || 0,\n            y: options.y || 0,\n            width: options.width || surface.canvas.width,\n            height: options.height || surface.canvas.height\n         }\n      }\n\n      displayAll() {\n         var i = this.order.length;\n         while (i--) {\n            this.display(this.order[i].name)\n         }\n      }\n\n      display(surfaceName) {\n         var surface = this.list[surfaceName]\n         // destination\n         var dx = 0\n         var dy = 0\n         var dWidth = this.cs.canvas.width\n         var dHeight = this.cs.canvas.height\n\n         // source\n         var sx = dx\n         var sy = dy\n         var sWidth = dWidth\n         var sHeight = dHeight\n\n         if (!surface.oneToOne) {\n            var cameraRect = this.cs.camera.info()\n            sx = cameraRect.x\n            sy = cameraRect.y\n            sWidth = cameraRect.width\n            sHeight = cameraRect.height\n\n            // safari does not allow negative source\n            if (sy < 0) {\n               dy -= sy * cameraRect.zScale\n               sy = 0\n               sHeight = surface.height\n               dHeight = sHeight * cameraRect.zScale\n            }\n\n            if (sx < 0) {\n               dx -= sx * cameraRect.zScale\n               sx = 0\n               sWidth = surface.width\n               dWidth = sWidth * cameraRect.zScale\n            }\n         }\n\n         this.cs.ctx.drawImage(surface.canvas,\n            sx, sy, sWidth, sHeight,\n            (dx), (dy), (dWidth), (dHeight)\n         )\n      }\n\n      resize() {\n         var width = this.cs.clampWidth\n         var height = this.cs.clampHeight\n\n         // set main canvas\n         this.ctxImageSmoothing(this.cs.ctx)\n\n         // loop over the surfaces to match\n         // a surface can be raw (screen coordinates) or not (the size of the room)\n         for (var surface of this.order) {\n            if (this.cs.loop.run) {\n               var save = surface.ctx.getImageData(0, 0, surface.canvas.width, surface.canvas.height)\n            }\n\n            surface.canvas.width = surface.oneToOne ? width : this.cs.room.width\n            surface.canvas.height = surface.oneToOne ? height : this.cs.room.height\n            surface.width = surface.canvas.width\n            surface.height = surface.canvas.height\n            this.clear({ name: surface.name })\n            this.ctxImageSmoothing(surface.ctx)\n\n            if (this.cs.loop.run) surface.ctx.putImageData(save, 0, 0)\n         }\n      }\n\n      ctxImageSmoothing(ctx) {\n         ctx.webkitImageSmoothingEnabled = this.imageSmoothing\n         ctx.mozImageSmoothingEnabled = this.imageSmoothing\n         ctx.msImageSmoothingEnabled = this.imageSmoothing\n         ctx.imageSmoothingEnabled = this.imageSmoothing\n      }\n\n      info(surfaceName) {\n         return {\n            canvas: this.list[surfaceName].canvas,\n            width: this.list[surfaceName].width,\n            height: this.list[surfaceName].height\n         }\n      }\n\n      debug(surfaceName) {\n         var canvas = this.cs.surface.list[surfaceName].canvas\n         canvas.style.position = 'fixed'\n         canvas.style.top = '50%'\n         canvas.style.left = '50%'\n         canvas.style.transform = 'translateX(-50%) translateY(-50%)'\n         canvas.style.background = '#222'\n         canvas.style.border = '2px solid #000'\n\n         document.body.appendChild(canvas)\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined' ? module.exports = CSENGINE_SURFACE : cs.surface = new CSENGINE_SURFACE(cs)\n})()\n","//----------------------------------------------------------------------------//\n//-----------------------------| CS ENGINE: STORAGE |-------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_STORAGE {\n      constructor(cs) {\n         this.cs = cs\n\n         this.data = {}\n      }\n\n      init() {\n         for (var storage of this.cs.storages) {\n            this.write(storage)\n         }\n      }\n\n      read(location) {\n         return JSON.parse(this.data[location])\n      }\n\n      write(options) {\n         this.data[options.location] = JSON.stringify(options.data)\n         if (options.save) this.save(options.location)\n      }\n\n      // reminds me of bash ls command\n      ls(location) {\n         var startsWith = cs.default(location, '')\n         var list = []\n         for (var storageName of Object.keys(this.data)) {\n            if (storageName.startsWith(startsWith)) {\n               list.push(storageName)\n            }\n         }\n         return list\n      }\n\n      save(location) {\n         // local storage\n         window.localStorage.setItem(location, this.data[location])\n      }\n\n      reset() {\n\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_STORAGE\n      : cs.storage = new CSENGINE_STORAGE(cs)\n})()\n","//----------------------------------------------------------------------------//\n//------------------------------| CS ENGINE: TIMER |--------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_TIMER {\n      constructor(cs) {\n         this.cs = cs\n\n         this.list = []\n         this.count = 0\n      }\n\n      loop() {\n         for (var timer of this.list) {\n            if(timer.time) timer.time += 1\n\n            timer.percent = timer.time / timer.duration\n\n            if(timer.percent == 1) {\n               timer.running = false\n\n               this.unWatch(timer)\n               timer.end && timer.end()\n            }\n         }\n      }\n\n      create(options) {\n         var timer = options.timer\n         if(!timer) {\n            this.count += 1\n\n            timer = {\n               id: this.count,\n               start: options.start,\n               end: options.end,\n               duration: options.duration,\n               time: 0,\n               percent: 0\n            }\n         }\n\n\n         //this.list.push(timer)\n         return timer\n      }\n\n      start(timer) {\n         if (timer.running) return\n\n         this.watch(timer)\n         timer.start && timer.start()\n         timer.running = true\n         timer.time = 1\n      }\n\n      watch(timer) {\n         this.list.push(timer)\n      }\n\n      unWatch(timer) {\n         this.list = this.list.filter(function(num) {\n            return num.id !== timer.id\n         })\n      }\n\n      isOn(timer) {\n         return timer.time > 0\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_TIMER\n      : cs.timer = new CSENGINE_TIMER(cs)\n})()\n","//----------------------------------------------------------------------------//\n//-----------------------------| CS ENGINE: VECTOR |--------------------------//\n//----------------------------------------------------------------------------//\n(() => {\n   class CSENGINE_VECTOR {\n      create(x, y) {\n         return { x: x, y: y }\n      }\n\n      clone(v) {\n         return cs.vector.create(v.x, v.y)\n      }\n\n      add(v0, v1) {\n         return cs.vector.create(\n            v0.x + v1.x,\n            v0.y + v1.y\n         )\n      }\n\n      min(v0, v1) {\n         return cs.vector.create(\n            v0.x - v1.x,\n            v0.y - v1.y\n         )\n      }\n\n      scale(v, s) {\n         return cs.vector.create(\n            v.x * s,\n            v.y * s\n         )\n      }\n\n      dot(v0, v1) {\n         return v0.x * v1.x + v0.y * v1.y\n      }\n\n      length(v) {\n         return Math.sqrt(v.x * v.x + v.y * v.y)\n      }\n\n      unit(v) {\n         return cs.vector.scale(v, 1/cs.vector.length(v))\n      }\n\n      distance(v0, v1) {\n         return cs.vector.length(cs.vector.min(v0, v1))\n      }\n\n      cross(v) {\n         return cs.vector.create(-v.y, v.x)\n      }\n\n      direction(v0, v1) {\n         return cs.vector.unit(cs.vector.min(v1, v0))\n      }\n   }\n\n   // export (node / web)\n   typeof module !== 'undefined'\n      ? module.exports = CSENGINE_VECTOR\n      : cs.vector = new CSENGINE_VECTOR(cs)\n})()\n","const PartCamera = require('./parts/Camera')\nconst PartDraw = require('./parts/Draw')\nconst PartFps = require('./parts/Fps')\nconst PartFullscreen = require('./parts/Fullscreen')\nconst PartInputKeyboard = require('./parts/InputKeyboard')\nconst PartInputMouse = require('./parts/InputMouse')\nconst PartInputTouch = require('./parts/InputTouch')\nconst PartLoader = require('./parts/Loader')\nconst PartLoop = require('./parts/Loop')\nconst PartMath = require('./parts/Math')\nconst PartNetwork = require('./parts/Network')\nconst PartObject = require('./parts/Object')\nconst PartRoom = require('./parts/Room')\nconst PartSetup = require('./parts/Setup')\nconst PartSound = require('./parts/Sound')\nconst PartSprite = require('./parts/Sprite')\nconst PartSurface = require('./parts/Surface')\nconst PartStorage = require('./parts/Storage')\nconst PartTimer = require('./parts/Timer')\nconst PartVector = require('./parts/Vector')\n\nmodule.exports = class cs {\n   constructor(options) {\n      const {\n         canvas,\n         assets\n      } = options\n\n      // 1. build engine\n      this.clone = function(object) { return JSON.parse(JSON.stringify(object)) }\n      this.default = function(want, ifnot) { return want != null ? want : ifnot }\n\n      // 1. build the engine\n      this.canvas = canvas\n      this.ctx = canvas.getContext('2d')\n      this.path = options.path\n      this.maxSize = options.maxSize || 2000\n      this.start = options.start\n      this.userStep = options.step\n      this.userDraw = options.draw\n      this.progress = options.progress || function() {}\n      this.focus = options.focus || function() {}\n      this.version = options.version || Math.random()\n      this.global = options.global || {}\n      this.progress = options.progress || function() {}\n      this.focus = options.focus || function() {}\n\n      this.objects = options.objects || {}\n      this.script = options.script || {}\n      this.sprites = options.sprites || []\n      this.storages = options.storages || []\n      this.sounds = options.sounds || []\n\n      this.assets = {\n         scripts: assets && assets.scripts ? assets.scripts : [],\n         sprites: assets && assets.sprites ? assets.sprites : [],\n         storages: assets && assets.storages ? assets.storages : [],\n         sounds: assets && assets.sounds ? assets.sounds : [],\n      }\n\n      this.camera = new PartCamera(this)\n      this.draw = new PartDraw(this)\n      this.fps = new PartFps(this)\n      this.fullscreen = new PartFullscreen(this)\n      this.inputKeyboard = new PartInputKeyboard(this)\n      this.inputMouse = new PartInputMouse(this)\n      this.inputTouch = new PartInputTouch(this)\n      this.loader = new PartLoader(this)\n      this.loop = new PartLoop(this)\n      this.math = new PartMath(this)\n      this.network = new PartNetwork(this)\n      this.object = new PartObject(this)\n      this.room = new PartRoom(this)\n      this.setup = new PartSetup(this)\n      this.sound = new PartSound(this)\n      this.sprite = new PartSprite(this)\n      this.storage = new PartStorage(this)\n      this.surface = new PartSurface(this)\n      this.timer = new PartTimer(this)\n      this.vector = new PartVector(this)\n\n      // 3. setup\n      this.loader.load()\n   }\n}\n","module.exports = {\n   create({ object, cs }) {\n   },\n\n   draw({ object, cs }) {\n      // console.log('draw')\n      cs.draw.setColor('red')\n      cs.draw.fillRect({\n         x: 0, y: 0, width: 100, height: 100\n      })\n   }\n}\n","// exmaple of a server side engine!\nconst CS = require('cs-engine')\n\nwindow.cs = new CS({\n   canvas: canvas,\n\n   objects: {\n      'block': require('./objects/block')\n   },\n\n   start: ({ cs }) => {\n      console.log('running start')\n\n      cs.object.create({\n         type: 'block'\n      })\n   }\n})\n","var OVERLAY_ID = '__parcel__error__overlay__';\n\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n\n  module.bundle.hotData = null;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets, assetsToAccept;\n\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = process.env.HMR_HOSTNAME || location.hostname;\n  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + ':' + process.env.HMR_PORT + '/');\n  ws.onmessage = function(event) {\n    checkedAssets = {};\n    assetsToAccept = [];\n\n    var data = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      var handled = false;\n      data.assets.forEach(function(asset) {\n        if (!asset.isNew) {\n          var didAccept = hmrAcceptCheck(global.parcelRequire, asset.id);\n          if (didAccept) {\n            handled = true;\n          }\n        }\n      });\n\n      // Enable HMR for CSS by default.\n      handled = handled || data.assets.every(function(asset) {\n        return asset.type === 'css' && asset.generated.js;\n      });\n\n      if (handled) {\n        console.clear();\n\n        data.assets.forEach(function (asset) {\n          hmrApply(global.parcelRequire, asset);\n        });\n\n        assetsToAccept.forEach(function (v) {\n          hmrAcceptRun(v[0], v[1]);\n        });\n      } else {\n        window.location.reload();\n      }\n    }\n\n    if (data.type === 'reload') {\n      ws.close();\n      ws.onclose = function () {\n        location.reload();\n      }\n    }\n\n    if (data.type === 'error-resolved') {\n      console.log('[parcel]  Error resolved');\n\n      removeErrorOverlay();\n    }\n\n    if (data.type === 'error') {\n      console.error('[parcel]   ' + data.error.message + '\\n' + data.error.stack);\n\n      removeErrorOverlay();\n\n      var overlay = createErrorOverlay(data);\n      document.body.appendChild(overlay);\n    }\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n  }\n}\n\nfunction createErrorOverlay(data) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n\n  // html encode message and stack trace\n  var message = document.createElement('div');\n  var stackTrace = document.createElement('pre');\n  message.innerText = data.error.message;\n  stackTrace.innerText = data.error.stack;\n\n  overlay.innerHTML = (\n    '<div style=\"background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;\">' +\n      '<span style=\"background: red; padding: 2px 4px; border-radius: 2px;\">ERROR</span>' +\n      '<span style=\"top: 2px; margin-left: 5px; position: relative;\"></span>' +\n      '<div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">' + message.innerHTML + '</div>' +\n      '<pre>' + stackTrace.innerHTML + '</pre>' +\n    '</div>'\n  );\n\n  return overlay;\n\n}\n\nfunction getParents(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || (Array.isArray(dep) && dep[dep.length - 1] === id)) {\n        parents.push(k);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction hmrApply(bundle, asset) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (modules[asset.id] || !bundle.parent) {\n    var fn = new Function('require', 'module', 'exports', asset.generated.js);\n    asset.isNew = !modules[asset.id];\n    modules[asset.id] = [fn, asset.deps];\n  } else if (bundle.parent) {\n    hmrApply(bundle.parent, asset);\n  }\n}\n\nfunction hmrAcceptCheck(bundle, id) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n\n  if (!modules[id] && bundle.parent) {\n    return hmrAcceptCheck(bundle.parent, id);\n  }\n\n  if (checkedAssets[id]) {\n    return;\n  }\n  checkedAssets[id] = true;\n\n  var cached = bundle.cache[id];\n\n  assetsToAccept.push([bundle, id]);\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n\n  return getParents(global.parcelRequire, id).some(function (id) {\n    return hmrAcceptCheck(global.parcelRequire, id)\n  });\n}\n\nfunction hmrAcceptRun(bundle, id) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n  if (cached) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n\n  cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      cb();\n    });\n    return true;\n  }\n}\n"]}